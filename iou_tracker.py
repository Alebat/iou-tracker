# ---------------------------------------------------------
# IOU Tracker
# Copyright (c) 2017 TU Berlin, Communication Systems Group
# Licensed under The MIT License [see LICENSE for details]
# Written by Erik Bochinski
# ---------------------------------------------------------

from time import time

import numpy as np

from .util import load_mot, iou


def track_iou(detections, sigma_l, sigma_h, sigma_iou, t_min, ttl, mom_alpha=0.95, exp_zoom=1.05):
    """
    Simple IOU based tracker, edited to use simple image features and momentum
    See "High-Speed Tracking-by-Detection Without Using Image Information by E. Bochinski, V. Eiselein, T. Sikora" for
    more information.

    Args:
         detections (list): list of detections per frame, usually generated by util.load_mot
         sigma_l (float): low detection threshold.
         sigma_h (float): high detection threshold.
         sigma_iou (float): IOU threshold.
         t_min (float): minimum track length in frames.
         ttl (float): maximum number of frames in which momentum is used to resolve missing detections.
         mom_alpha (float): forget factor of the momentum low pass filter.
         exp_zoom (float): rate at which the bounding box is zoomed when the detection is missing.

    Returns:
        list: list of tracks.
    """

    tracks_active = []
    tracks_finished = []

    for frame_num, detections_frame in enumerate(detections, start=1):
        # apply low threshold to detections
        dets = [det for det in detections_frame if det['score'] >= sigma_l]

        updated_tracks = []
        for track in tracks_active:
            if len(dets) > 0:
                # get det with highest iou and similarity score
                best_match = max(dets, key=lambda x: iou(predict_bbox(exp_zoom, track), x['bbox']))
                if iou(track['bboxes'][-1], best_match['bbox']) >= sigma_iou:
                    track['bboxes'].append(best_match['bbox'])
                    track['max_score'] = max(track['max_score'], best_match['score'])
                    if track['inactive'] > 0:
                        track['inactive'] = 0
                    elif len(track['bboxes']) > 1:
                        mom = track['momentum']
                        prev_bbox = np.array(track['bboxes'][-2]).reshape(2, 2)
                        bbox = np.array(track['bboxes'][-1]).reshape(2, 2)

                        track['momentum'] = mom * mom_alpha + (bbox - prev_bbox) * (1 - mom_alpha)

                    updated_tracks.append(track)

                    # remove from best matching detection from detections
                    del dets[dets.index(best_match)]

            # if track was not updated, use momentum for 'ttl' frames
            if len(updated_tracks) == 0 or track is not updated_tracks[-1]:
                # if the track's ttl is over
                if track['inactive'] > ttl:
                    # finish track when the conditions are met
                    if track['max_score'] >= sigma_h and len(track['bboxes']) - track['inactive'] >= t_min:
                        if track['inactive'] > 0:
                            del track['bboxes'][-track['inactive']:]
                        tracks_finished.append(track)
                else:
                    # else use momentum
                    # move the bbox and zoom it
                    moved_bbox = predict_bbox(exp_zoom, track)

                    track['bboxes'].append(moved_bbox)
                    track['inactive'] += 1

                    updated_tracks.append(track)

        # create new tracks
        new_tracks = [
            {
                'bboxes': [det['bbox']],
                'max_score': det['score'],
                'start_frame': frame_num,
                'momentum': np.zeros((2, 2)),
                'inactive': 0,
            }
            for det in dets
        ]
        tracks_active = updated_tracks + new_tracks

    # finish all remaining active tracks
    tracks_finished += [track for track in tracks_active
                        if track['max_score'] >= sigma_h and len(track['bboxes']) >= t_min]

    return tracks_finished


def predict_bbox(exp_zoom, track):
    bbox = np.array(track['bboxes'][-1]).reshape(2, 2)
    mom = track['momentum']
    center = np.average(bbox, axis=0)
    relative_bbox = bbox - center
    moved_bbox = center + exp_zoom * relative_bbox + mom
    return list(moved_bbox.flatten())


def track_iou_mom(detections, sigma_l, sigma_h, sigma_iou, t_min):
    """
    Simple IOU based tracker.
    See "High-Speed Tracking-by-Detection Without Using Image Information by E. Bochinski, V. Eiselein, T. Sikora" for
    more information.

    Args:
         detections (list): list of detections per frame, usually generated by util.load_mot
         sigma_l (float): low detection threshold.
         sigma_h (float): high detection threshold.
         sigma_iou (float): IOU threshold.
         t_min (float): minimum track length in frames.

    Returns:
        list: list of tracks.
    """

    tracks_active = []
    tracks_finished = []

    for frame_num, detections_frame in enumerate(detections, start=1):
        # apply low threshold to detections
        dets = [det for det in detections_frame if det['score'] >= sigma_l]

        updated_tracks = []
        for track in tracks_active:
            if len(dets) > 0:
                # get det with highest iou
                best_match = max(dets, key=lambda x: iou(track['bboxes'][-1], x['bbox']))
                if iou(track['bboxes'][-1], best_match['bbox']) >= sigma_iou:
                    track['bboxes'].append(best_match['bbox'])
                    track['max_score'] = max(track['max_score'], best_match['score'])

                    updated_tracks.append(track)

                    # remove from best matching detection from detections
                    del dets[dets.index(best_match)]

            # if track was not updated
            if len(updated_tracks) == 0 or track is not updated_tracks[-1]:
                # finish track when the conditions are met
                if track['max_score'] >= sigma_h and len(track['bboxes']) >= t_min:
                    tracks_finished.append(track)

        # create new tracks
        new_tracks = [{'bboxes': [det['bbox']], 'max_score': det['score'], 'start_frame': frame_num} for det in dets]
        tracks_active = updated_tracks + new_tracks

    # finish all remaining active tracks
    tracks_finished += [track for track in tracks_active
                        if track['max_score'] >= sigma_h and len(track['bboxes']) >= t_min]

    return tracks_finished


def track_iou_matlab_wrapper(detections, sigma_l, sigma_h, sigma_iou, t_min):
    """
    Matlab wrapper of the iou tracker for the detrac evaluation toolkit.

    Args:
         detections (numpy.array): numpy array of detections, usually supplied by run_tracker.m
         sigma_l (float): low detection threshold.
         sigma_h (float): high detection threshold.
         sigma_iou (float): IOU threshold.
         t_min (float): minimum track length in frames.

    Returns:
        float: speed in frames per second.
        list: list of tracks.
    """

    detections = detections.reshape((7, -1)).transpose()
    dets = load_mot(detections)
    start = time()
    tracks = track_iou(dets, sigma_l, sigma_h, sigma_iou, t_min)
    end = time()

    id_ = 1
    out = []
    for track in tracks:
        for i, bbox in enumerate(track['bboxes']):
            out += [float(bbox[0]), float(bbox[1]), float(bbox[2] - bbox[0]), float(bbox[3] - bbox[1]),
                    float(track['start_frame'] + i), float(id_)]
        id_ += 1

    num_frames = len(dets)
    speed = num_frames / (end - start)

    return speed, out
